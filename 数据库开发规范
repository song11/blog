MySQL数据库设计开发规范
作者:	Nieli
创建日期:	2018-07-18
最近更新:	2018-12-12
控制编号:	 
版本:	 1.0

日期	作者	版本	参考
			
2018-08-09	nieli	1.0	
2018-08-10	nieli	1.1	last_update_time 增加  ON UPDATE NOW()   
2018-10-13	Nieli	1.2	精简细化规范
2018-12-10	Nieli	1.3	精简细化规范，添加一些举例说明，根据实际需要添加新的标准




审批:
	
	
      




目录
 概述,目的，适应围………………………………………………………………………………………………………………………………3
一．	数据库基础规范………………………………………………………………………………………………………………………………4
二. 命名规范总表…………………………………………………………………………………………………………………………………4
三.	表,字段设计规范…..………………………………………………………………………………………………………………………5
1. 建表基出规则…………………………………………………………………………………………………………………………5
2. 表,字段命名规则………………………………………………………………………………………………………………………5
3. 字段类型及设计规则…………………。。…………………………………………………………………………………………5
   四．索引设计规范…………………………………………………………………………………………………………………………………7
1.索引命名规范………………………………………………………………………………………………………………………………7
     2.索引在数量上相关控制要求……………………………………………………………………………………………………………7
     3.主键设计准则………………………………………………………………………………………………………………………………7
     4.索引禁止，不准，避免准则……………………………………………………………………………………………………………7
     5.索引设计必需遵守准则…………………………………………………………………………………………………………………8
     6.索引设计的一些建议准则………………………………………………………………………………………………………………8
7.索引补充知识（性能优化参考）……………………………………………………………………………………………………9
五.  SQL语句设计规范……………………………………..……………………………………………………………………………………10
1.SQL基本要求准则………………………………………………………………………………………………………………………10
2. SQL中对空值处理………………………………………………………………………………………………………………………10
3.SQL影响操作安全或数据准确性方面的准则……………………………………………………………………………………10
4. SQL中字类型不一致，导致不走索引，影响性能……………………………………………………………………………11
隐式转换规则…………………………………………………………………………………………………………………………………11
5.设计问题，影响性能………………………………………………………………………………………………………………………11
六. 注释规范………………………………………………………………………………………………………………………………………13
七. 行为规范, 流程规范 ………………………………………………………………………………………………………………………13



概述
为了强化软件开发标准/规范执行力, 提高 软件产品的一次性通过率,特对现有的开发规范进行了重新整理,本文仅包括MySQL数据库层设计及开发规范。
目的
1.	规范应用程序的结构和编码风格标准化，便于阅读和理解。为软件的维护提供有效的支持；
2.	为了更好的协同工作和确保所有开发的应用尽可能的稳定，高效
3.	让新的研发人员尽快的的融入研发体系，还可以极大的减少DBA和研发团队，测试团队的沟通效率。
2．监督软件开发规范/标准执行。
适用范围
1.	公司范围内所有基于MySQL数据库的所有开发活动。


















红黑说明
红色：标色为必须遵守规则
黑色：为建议规则，开发经给，要求懂得原理，根据具体需求设计最合理的表结构，索引，及SQL语句

一、数据库层基础规范  (必须全部遵守)
1．使用 INNODB 存储引擎
2.  库命名要有代表性意义，简洁,长度不过15个字，便于记忆和书写
3．数据库默认字符集使用 utf8mb4
4.  数据库默认字符内部排序规则使用tf8mb4_gueneral_ci
5．禁止在线上做数据库压力测试
6．禁⽌从测试、开发环境直连生产数据库
7.  禁止在数据库中使用VARBINARY、BLOB存储图片、文件等, mysql不适合存储这种对象，可以将大对象放到磁盘上，数据库中存储它的路径

二、对象命名规范汇总表 (必须全部遵守)
对象名	前缀或者后缀	范例	描述
表(table)	现有表sf_, pub_ 或其它，根据业务定义	sf_activity_order_coupon	表名长度原则上不超过30 个字符, activity子服务，order子服务对应的模块，coupon模块的表名，
视图(view)	vv_	vv_sf_shelf	如果表名过长，则用表名的缩写,但必须有可读意义,
一般索引(normal index)	idx_	idx_sf_shelf_addtime	如果是复合索引，后面可以接多个字段名用_分隔, 
表名太长,又有多个字段索引,可以不加表名,
可以直接idx__addtime_address
唯一索引(unique index)	uk_	uk_sf_shelf_code	前缀+表名+唯一字段名
主键(primary key)	pk_	pk_sf_shelf_id 或
primary key(.. )数据库默认	前缀+表名+主键字段名　
外键(foreign key)	fk_	fk_sf_shelf_company_id	前缀+表名+外键字段名 
(我们不用外键标识，统一采用上述一般索标识，idx _
触发器(triger)	tri_	tri_sf_shelf	前缀+表名
过程(procedure)	prc_	prc_found_shelf()	前缀+有意义的功能逻辑名字
函数(function)	fun_	fun_found_shelf()	前缀+有意义的功能逻辑名字
保存点(savepoint)	spt_	spt_book1	savepoint  spt_book1
游标(cursor)	cur_	cur_shelf	DECLARE cur_shelf  CURSOR FOR SELECT shelf_id FROM sf_shelf
变量	v_	v_name	
输入参数变量	p_	p_shelf_id	DELIMITER $$
CREATE PROCEDURE get_shelf_name(IN p_id BIGINT(20),OUT o_code VARCHAR(50),INOUT  x_name VARCHAR(50))
BEGIN
   SET @v_shelf_id=p_id;
   SELECT  t.`SHELF_CODE`,t.`SHELF_NAME` INTO  o_code,x_name FROM sf_shelf  t WHERE t.`SHELF_ID`=@v_shelf_id;
   SELECT o_code,x_name ;
END;
$$
dilimiter ;
输出参数变量	o_	o_shlef_code	
输入输出参数变量	x_	x_shelf_name	







三. 表,字段设计规范 (红色为必须遵守，黑色为建议参考标准)
1.建表基出规则 
1.所有表名，字段都需要添加注释 
2.所有表必须使用InnoDB存储引擎
3.所有表字符集必须使用utf8mb4
4.表字符内部排序规则使用utf8mb4_general_ci
5.表结构变化(DDL）更需要通知DBA审核并进行更新
6.禁止在数据库中直接存储明文密码及敏感字段内容，必须电话号码，要对其进行加密后存储
7.单表数据量建议控制在 5000W 以内，行数超过5000W，数据量超过2G可建议分库分表，或者分区表
说明：如果预计三年后的数据量根本达不到这个级别，就暂时不要在创建表时建分库分表，需要时再创建。

2.表,字段命名规则  (需全部遵守)
1. 表名、字段名必须使用小写字母，可以下划线分隔, 禁止出现数字开头，禁止两个下划线中间只出现数字
   说明： 合理 sf_shelf  pub_member    不合理: SF_SHELF,  1_sf_shelf,  sf_123_shelf
2. 表名、字段名,最多支持64个字符, 为了统一规范、易于辨识和记忆以及减少传输量，长度不超过30个字符
   说明： 合理 sf_shelf  pub_member    不合理: sf_take_create_order_count_pubs  
          不合理       create table pub_import_fill_order (import_fill_order_id int, pub_import_fill_order_name varchar(20)
3. 表名、字段名取旬必须有意义，意义要与业务名称的作用尽量一致,建议使用名词而不是动词，也不要半洋半中
   说明： 合理 pub_logs                不合理: sf_abc_123,   sf_订单
4.	 禁用直接用保留字作表名，字段名，如 desc、range、match、delayed 等,可参考 MySQL 官方保留字
   说明： 合理 pub_logs                不合理:  create table range(range_id int)
5. 表达是否,类型,状态,标志等概念类型的字段，必须使用status, _type, _flag等有意义的词眼为后缀命名
数据类型必须是 tinyint, 
比如data_flag     数据状态(1:正常、2:删除)
   说明： 合理 (data_flag tinyint) , (user_type tinyint)         不合理:  user_type bigint(20),  data_falg varchar(10)
6.	对于数据标识类型字段，基于目前丰宜开发现状况，
方法1:一部分是采用数据字典（pub_dictionary_type ，pub_dictionary_item来保存的
方法2: 一部分是直接用值来保存，标识值说明是写在字段备注当中
   要求
在设计表时对业务进行预估，将来类型值不超过6种，可用用方法2，有可能超过6种必须采用方法1.
   采用方法1时  开发发版提交更新维护值时，请交SQL语句来更新数据字典的值
采用方法2时，类型,标志追加维护修改值时,必须及时更新字段备注信息

7. 创建表的时候各字段不要加上引号,以免后续出现麻烦
   说明： 合理 create table sf_shelf(..)    不合理:  create table "sf_ shelf"   "sf_shelf "   "sf_SHELF" 
8. 按功能用途加相应的后缀 
a)中间表临时表必须加上 tmp/temp 后缀，         比如: pub_user_growth_record_tmp
b)统计表必须加上加上stat/statistic后缀，           比如:pub_user_growth_stat
c)存放业务表的历史数据所可以加上his/hisotr y后缀  比如: sf_coupon_analysis_his
d)备份表格式为表名_创建人_日期_bak, 以便DBA确认是谁建立，何时建立（如果命名过长，可以临时超出规定30的长度）
      备份表必须建在每个数据库实例下的fe_bak库
备份表保存一段时间（一个月，两个月），DBA需要根据时间定期删除
  例fe_bak.sf_order_nieli_20180731_bak

新建表大致格式如下
create table `sf_shelf` (
  `shelf_id` bigint(20) not null auto_increment comment '货架编号',
  `shelf_name` varchar(50)  not null default '' comment '货架名称',
  `shelf_code` varchar(50)  not null default '' comment '货架编码',
  `shelf_random_code` varchar(50) not null default '' comment '货架随机码',
  `company_id` bigint(20)         not null default 0 comment '公司编号',
  `shelf_type` int(2)             not null default 1 comment '货架类型(参考数据字典shelftype 1:四层标准货架、2:冰箱、3:五层防鼠货架、4:虚拟货架、5:冰柜、9:前置仓)(dict)',
  primary key (`shelf_id`),     
  key `idx_sf_shelf_code` (`shelf_code`),
  key `idx_sf_shelf_city` (`city`)
) engine=innodb comment='货架信息';
 对于字符集属性DEFAULT CHARSET无需填写，默认继承数据库的字符集属性
 对于提交生产库AUTO_INCREMENT语句也需去掉，默认从1开始



3. 字段类型及设计规则(红色为必须遵守，黑色为建议参考标准)
1. 存储精确浮点数必须使用DECIMAL,小数类型为decimal，禁止使用 float 和 double。 
说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。
对于货币、金额这样的类型，使用decimal，如 decimal(9,7)。float默认只能能精确到6位有效数字
如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储

2.  必须要有主键, 类型为自增整型，建议不要用UUID/HASH/MD5类型作为主键（特殊需求除外）,并且主键id不能有业务意义
3.  和其他主表有关联的表字段，将来用作表联, 字段必须使用相同的列名，字段类型以及长度也必须完全相同
4.  所有表必须增加以下5个基本字段，如下所示:
data_flag           TINYINT    NOT NULL DEFAULT 1       COMMENT '数据状态(1:正常、2:删除)',    
add_time           DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP  COMMENT '添加时间',
add_user_id         BIGINT     NOT NULL DEFAULT 0       COMMENT '添加人员id',
last_update_time    DATETIME   NOT NULL DEFAULT CURRENT_TIMESTAMP  ON UPDATE CURRENT_TIMESTAMP  COMMENT '最后修改时间',
last_update_user_id  BIGINT     NOT NULL DEFAULT 0       COMMENT '最后修改人员id',

要求：
1). 开发程序代码中处理逻辑和查询时一定需要记得带上条件data_flag/或is_delete字段，以防数据重复
2). 目前系统中有些表使用的是用is_delete作为删除标志，原来已正式上线的业务表暂不做改动，
   以后新设计的业务表以及未上线的表均采用用data_flag 做数据删除标志，规则进行统一。
3). 开发程序中增加数据时需要给add_user_id字段赋值，其它字段有默认值
4). 开发程序中修改数据时需要给last_update_user_id字段赋值，其它字段有默认值
5).  DBA和运维在维护数据行时需要更新last_update_user_id

5. 只存储年使用year类型。
6. 只存储日期使用date类型
7 如果存储的字符串长度几乎相等，可以使用 char 定长字符串类型
8.  varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，
定义字段类型为 text，独立出来一张表, 用主键来对应,避免影响其它字段索引效率
9.  尽量不使用text、blob类型, varchar 的性能会比 text 高很多，实在避免不了text, blob，可以拆表分开存储
10. VARCHAR(N)，N表示的是字符数不是字节数，比如VARCHAR(255)可以最大可存储255个字符，需要根据实际的宽度来选择N。
11. VARCHAR(N)，N尽可能小，因为MySQL一个表中所有的VARCHAR字段最大长度是65535个字节，进行排序和创建临时表一类的内存操作时，会使用N的长度申请内存。
12. 存储日期时间(精确到秒)，建议使用TIMESTAMP类型，因为TIMESTAMP使用4字节，DATETIME使用8个字节。
       timestamp显示与时区有关，内部总是以UTC(协调世界时)毫秒来存的。受到严格模式的限制
13. 建议所有字段定义为NOT NULL,  NULL字段很难进行查询优化，NULL字段的索引需要额外空间
    如果是索引字段，强烈建议定义为not null 。因为null值会影响cardinality 统计,影响优化器对索引的选择
如果不能保证insert时一定有值过来，定义时字符型使用default ‘’ ，数字型使用 default 0
14单表何时拆分成多个表
1)	字段数目量尽量不超过30左右，再多的话可以考虑垂直分表，
2)  一访问频率低的字段可以单独分一张表，实现冷热数据分离，
3)	 二是大字段分离,比如text字段，blob字段可单独拆分到一个表里
4)  表字段控制少而精，可以提高IO效率，内存缓存更多有效数据，从而提高响应速度和并发能力，后续alter table 也更快。
15.  数据库表设计必须满足到第三范式
      第一范式： 数据库表的每一列都是不可分割的原子数据项
第二范式：每一个非主属性，必须完全依赖于主键，要消除部分依赖
第三范式： 消除非主属性传递依赖于主属性
如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，
这被称作传递依赖于主属性
16. 适用使用反范式设计提高程序性能，有时我们做设计时可以不严格遵循范式,在一些表上增加冗余字段来减少
避免大表、多表的关联查询来提高数据库的查询性能 
字段允许适当冗余，以提高查询性能，但必须保证表中冗余字段数据一致，
冗余字段应遵循
1）不是频繁修改的字段。 
2）不是 varchar超长字段，更不能是 text 字段, 这种占用大量空间资源，冗余过于浪费，关联表后也影响性能
3) 不是通过变量计算型保存的字段
4) 如果在维护资料时修改了源表的这个字段，必须在应用程序中保证同步修改其它表中的这个冗余字段，保证数据一致性，
   最好是通过事务控制来修改，要么都修改成功，要么都修改不成功。
正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。
17. 存储ip最好用int存储而非char(15),存储前，读取时可以使用inet_aton(),inet_ntoa()函数转换
18. 能用int的就不用char或者varchar,能用tinyint的就不用int，能用varchar(20)的就不用varchar(255)，char也一样，
合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。
 正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围



的年龄定义 tinyint就行,定义bigint完全没必要，浪费空间和性能。

19. 如果能预见要创建的表非常大，比如大于1000万条记条，而且业务复杂，将来有可能会增加字段，创建表时可创建预留字段
必须包括如下字段：
attribute1        VARCHAR(100);
attribute2        VARCHAR(100) ;
attribute3        VARCHAR(100) ; ;
attribute4        BIGINT(20);
attribute5        BIGINT(20);

四. 索引设计规范 (红色为必须遵守，黑色为建议参考标准)
1.索引命名规范 (需全部遵守)
1). 索引名称必须使用小写, 可以用下划线分隔, 禁止出现数字开头
 说明： 合理 idx_shelf_addtime     不合理: IDX_SHELF_ADDTIME,  1_idx_sf_shelf  
2). 非唯一索引必须按照“idx_表名_字段名称1_字段名称2[_字段名]”进行命名, 如果字段比较多，可以省去表名，节约名字长度
 说明： 合理 表名sf_shelf_check   索引为idx_sf_shelf_check_operatetime  idx_operatetime_user_id    
3). 唯一索引必须按照“uk_表名_字段名称1_字段名称2[_字段名]”进行命名,如果字段比进行命名多，可以省去表名，节约名字长度
 说明： 合理 表名sf_shelf  唯一索引为 uk_sf_shelf_code  uk_code_managerid 多字段时可省略中间表名
4). 主键索引按“pk_表名_字段名”进行命名,如果字段比较多,可以省去表名,节约名字长度, 
默认新建表时也可采用primary key (主键字段) 来命名主键


2. 索引在数量上的控制要求(红色为必须遵守，黑色为建议参考标准)
1.)数据量超过1000 行的表应该有索引
2).单个索引中的字段数不要超过5个
3).单个字段上不要超过2个索引（即一个单字段最多可在上面建立一个单字段索引和一个组合字段索引
 例：
  create index idx_sf_shelf_product_id(product_id)
  create index idx_sf_shelf_shelf_id_product_id(shelf_id,product_id)
 
4). 单张表的索引数量控制在5个以内, 索引并不是越多越好。索引可以提高查询的效率，但会降低写数据的效率。有时不好的索引还会降低查询的效率,若单张表在查询需求上需要在多个字段上单独用到索引，需要经过评估取舍才建，可以找DBA协助分析
5). 生产环境中单个SQL进行join关系的表不要超过4个。关联表太多，特别是大表集合严重影响查询和处理性能
多表关联查询时,保证被关联的字段需要有索引，关联字段数据类型必须一致； 
即使双表 join 也要注意表，索引、SQL性能。
6). 对字符串可以考虑使用前缀索引，前缀索引长度不超过20个字符,
5.7版本最大索引前缀长度3072字节
5.6版本将最大索引前缀长度767字节、 
在varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。 
说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，
可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定区分度。
例子： create index idx_sh_shelf_a on sf_shelf(shelf_name(20));

3.主键设计准则  (红色为必须遵守，黑色为建议参考标准)
1). 表必须也有主键, 如果没有主键或唯一索引，update/delete是通过所有字段来定位操作的行，相当于每行就是一次全表扫描
2). 主键不允许更新
3). 唯一键不和主键重复，即唯一键中不包含主键
4). 尽量不选择字符串列作为主键
5). 没有唯一业务字段键或者唯一键不符合"单张表的索引数量控制在5个以内“时，建议选择自增或发号器来做主键
6). 主键类型为建议为自增整型，最好不要用UUID/HASH/MD5类型作为主键, 这些作为主键(数值太离散了),插入性能低下，
并且主键id不能有业务意义
7).  主键是一种聚集索引，一般是单字段顺序写入。如果是复合唯一索引作为主键的话，是随机写入，适合写少读多的表
8).  如果没有指定主键，默认使⽤非空的唯一键作为主键


4. 索引规范中一些禁止，不准，避免约定(红色为必须遵守，黑色为建议参考标准)
1.  频繁DML的表，不要建立太多的索引；
2  不在低基数的字段,或选择性低的字段上建立索引，例如 性别，类型字段
3  不在索引列进行数学运算和函数运算，这样就算有索引，也不会走索引
       例: where DATE_FORMAT(create_date,'%Y-%m-%d')='2018-12-10'
4.  使用EXPLAIN判断SQL语句是否合理使用索引，尽量避免extra列出现：Using File Sort，UsingTemporary。
5.  字段搜索严禁左模糊或者全模糊，如果需要请利用搜索引擎来解决(全文索引，或反转索引）  
说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。
例:  where name LIKE “%weibo”，索引会失交效，不走索引
6.  不使用数据库外键, 建立外键约束后的表在插入数据时要进行数据参照完整性检查，这会导致消耗数据库性能
说明
1) 外键用来保护参照完整性，可在业务端实现
2) 对父表和子表的操作会相互影响，降低可用性
3) 虽然不使用MySql自带的外键，但一定在表与表之间的关联字段键上建立索引
7.   避免冗余的索引，如：primary key(id)，index(id)，unique index(id)
8 .  避免重复的索引，如：index(a,b,c)，index(a,b)，index(a)
重复的和冗余的索引会降低查询效率，也浪费资源，因为MySQL查询优化器会不知道该使用哪个索引
9. 不要给表中的每一列都建立单独的索引。设计良好的联合索引比每一列上的单独索引效率要高出很多 

10.  索引字段的默认值不能为NULL，要改为其他的default或者空。NULL非常影响索引的查询效率
11. 创建索引时避免有如下极端误解： 
1）宁滥勿缺。认为一个查询就需要建一个索引。
2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 
3）抵制惟一索引，认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。







5. 索引设计其它的一些遵守准则(需全部遵守)
1). 能使用唯一索引就要使用唯一索引，提高查询效率
2). 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 
说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但是相对于提高查找速度是高效,明显的；
另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。
3).必须防止因字段类型不同造成的隐式转换，导致索引失效
  例: 比如这里shelf_id 为字符型，  where shelf_id=15  ,即使shelf_id有索引，也不会使用索引，而走全表扫描
      系统默认是字符型向数字型转换，这里用到了隐式转换，转成数字型
4). 更新UPDATE, DELETE SQL中，where 所带的字段必须索引，
如果update,delete where字段不加索引，哪怕更新一行数据，也会锁全表，阻塞任何更新
例: update sf_order where SHELF_ID=1 and product=12 
   如果shelf_id 和product_id 上没有索引，更新sf_order 会锁全表

5). ORDER BY，GROUP BY，DISTINCT的字段需要添加在复合索引的靠后面部分
      如有如下order by的场景，利用索引的有序性。order by字段是组合索引的一部分，并且放在索引组合顺序的后面，
避免出现 file_sort 的情况，影响查询性能。 
正例：where a=? and b=?  order by c;  (联引索引字段a,b,c 索引名： idx_a_b_c)
反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引 a_b 无法排序。


6． 索引设计其它的一些建议参考准则（开发经验，须掌握理）
1). 删除不再使用或者很少使用的索引
2). 对长度过长的VARCHAR字段建立索引时，可以添加crc32或者MD5 Hash字段，再对Hash字段建立索引。
3). 复合索引字段的顺序需要考虑字段值去重之后的个数，个数多，即选择性高, 区分度高的的放在左边
选择性更高的字段放在组合字段索引的前面, 如果字段选择性接近，则把频繁查询的字段放在前面
a）例外: 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>? and b=? 
那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。
 create index idx_b_a

b) 如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可, a字段已经过滤大部分行
4). 覆盖索引定义
就是一个索引中包含了这条SQL语句中所有涉及字段，包括select字段,where字段以及关联字段
也包括出现在select从句，order by和group by从句中的列

举例说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？
浏览一下目录就好，目录已经包含了标题，这个目录就是起到覆盖索引的作用。 
用 explain 显示执行计划，extra 列会出现：using index。说明走了覆盖索引，无需回表

对于频繁的查询优先考虑使用覆盖索引，利用覆盖索引来进行查询操作
覆盖索引优点：
a)避免Innodb表进行索引的二次查找，避免回表
   b)可以把随机IO变为顺序IO加快查询效率

5).  需要在字段建立索引的场合
a). 频繁出现在where子句里的字段建议建立索引；
b). 用来和其他表关联的字段建议建立索引；
c). 字段有高的选择性和过滤性（count(distinct)/count(*)>0.6）；
d). 一般建议在查询数据量10%以下使用索引；
6). 执行计划访问优化目标顺序   all,index,rang,ref,eq_ref, const, system,null ,越往右，性能越好
   SQL性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好
说明： 
a）	all    全表扫描
b）	index  覆盖索引，全索引扫描, 把索引从头到尾扫一遍
c）	range 对索引进行范围检索, 常见于使用>,<,is null,between ,in ,like等运算符的查询中
d）	ref    指的是使用的辅助索引索引相等条件检索，或者唯一索引，主键的左模糊查询（normal index）,
e）	eq_ref常见于主键 或 唯一索引扫描常出现在要连接过多表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表 
     的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref，
f）	consts 使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一 
 索引扫描 
g) system 表中只有一行数据或者是空表，且只能用于myisam和memory表,一般是系统表, 如果是Innodb引擎表，type列在这个情况通常都是all或者index
h). null  MySQL在优化过程中分解语句，执行时甚至不用访问表或索引
 


7. 索引补充知识（性能优化参考, 开发经验，须掌握,理解）
1.索引尽量建在选择性高的列上
(1)不在低基数列上建立索引，例如性别、类型。但有一种情况，idx_feedbackid_type (f_feedback_id,f_type)，如果经常用 f_type=1 比较，而且能过滤掉90%行，那这个组合索引就值得创建。有时候同样的查询语句，由于条件取值不同导致使用不同的索引，也是这个道理。
(2)索引选择性计算方法（基数 ÷ 数据行数）
Selectivity = Cardinality / Total Rows = select count(distinct col1)/count(*) from tbname，越接近1说明col1上使用索引的过滤效果越好
(3)当扫描行数超过30%时，可能不会走索引，改为全表扫描

2.最左前缀原则
1)mysql使用联合索引时，从左向右匹配，遇到索中断字段中断非连续或者范围查询时，无法用到后续的索引列
比如索引idx_c1_c2_c3 (c1,c2,c3)，相当于创建了(c1)、(c1,c2)、(c1,c2,c3)三个索引，
where条件包含上面三种情况的字段比较则可以用到索引，
但像 where c1=a and c3=c 只能用到c1列的索引，
像where c2=b and c3=c等情况就完全用不到这个索引
2)遇到范围查询(>、<、between、like)也会停止索引匹配，比如 c1=a and c2 > 2 and c3=c，只有c1,c2列上的比较能用到索引，
    Where c3=c 用不到索引
3)where条件里面字段的顺序与索引顺序无关，mysql优化器会自动调整顺序

3.前缀索引
1)对超过20个字符长度的列创建索引时，考虑使用前缀索引，如 idx_cs_guid2 (f_cs_guid(26))表示截取前26个字符做索引，既可以提高查找效率，也可以节省空间
2)前缀索引也有它的缺点是，如果在该列上 ORDER BY 或 GROUP BY 时无法使用索引，也不能把它们用作覆盖索引(Covering Index)
3)如果在varbinary或blob这种以二进制存储的列上建立前缀索引，要考虑字符集，括号里表示的是字节数,而非字符数

4.合理使用覆盖索引减少IO
INNODB存储引擎中，secondary index(非主键索引，又称为辅助索引、二级索引)没有直接存储行地址，而是存储主键值。
如果用户需要查询secondary index中所不包含的数据列，则需要先通过secondary index查找到主键值，然后再通过主键查询到其他数据列，因此需要两次查询。覆盖索引则可以在一个索引中获取所有需要的数据列，从而避免回表进行二次查找，节省IO因此效率较高。
例如SELECT email，uid FROM user_email WHERE uid=xx，如果uid不是主键，适当时候可以将索引添加为index(uid，email)，以获得性能提升。





五. SQL语句设计规范
1. SQL 基本要求准则(需全部遵守)
1. 避免生产业务上使用触发器、函数、视图存储过程; 存储过程难以调试和扩展，容易将业务逻辑和DB耦合在一起，更没有移植性
并且MySQL的存储过程、触发器、函数中存在一定的bug，

1). 存储过程虽然可以简化业务端代码，在传统企业写复杂逻辑时可能会用到，而在互联网企业变更是很频繁的，在分库分表的情况下要升级一个存储过程相当麻烦。又因为它是不记录log的，所以也不方便debug性能问题。如果使用过程，一定考虑如果执行失败的情况。
2) 使用视图一定程度上也是为了降低代码里SQL的复杂度，但有时候为了视图的通用性会损失性能（比如返回不必要的字段）。
3）触发器（trigger）也是同样，但也不应该通过它去约束数据的强一致性，mysql只支持“基于行的触发”，也就是说，触发器始终是针对一条记录的，而不是针对整个sql语句的，如果变更的数据集非常大的话，效率会很低。掩盖一条sql背后的工作，一旦出现问题将是灾难性的，但又很难快速分析和定位
2.  SQL中不能使用sleep()
3.  禁用insert into table1  select… from  table2 语句，此种语句会源表进行锁定，导致大量阻塞事务，甚至死锁。
REPEATABLE-READ是MySQL默认的事务隔离级别

分以下几种情况
1) . 源表按主键查询，不加任何条件 会对select的源表进行逐行锁定，逐步地锁定已经扫描过的记录
       insert into table1 select * from table2 order by id：
insert into table1 select * from table2 order by id dec;
2)  源表按非主键索引查询，索引字段不带任何条件时,会一开始就对源表进行全锁定
insert into table1 select * from table2 order by modified_date： 
3) 在查询条件中使用非主键索引，索引字段并使用筛选条件时，MySQL逐行加锁
      insert into table1 select * from table2 where modified_date>='2017-10-01 00:00:00'
     4) 无使用索引时，无论有没有条件筛选，将会一次对源表进行全表锁定

4.  update join ,delete join 操作同样会对相关联的表进行锁表，需要特别注意

2. SQL中对空值处理(红色为必须遵守，黑色为开发经验，必须掌握理)
1. 不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92定义的标准统计行数的语法，跟数据库无关，
跟 NULL 和非 NULL 无关。 
说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行
2.  count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值也返回为 0。
3．当某一列的值全是 NULL 时，count(col)的返回结果为 0，但sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。 
正例：可以使用如下方式来避免 sum 的 NPE 问题：SELECT IFNULL(SUM(g),0) FROM TABLE;
4. 使用 ISNULL  ,IS NOT NULL, IFNUL()来判断是否为 NULL 值。 说明：NULL 与任何值的直接比较都为 NULL。
   1） NULL<>NULL 的返回结果是 NULL，而不是 false。 
2） NULL=NULL 的返回结果是 NULL，而不是 true。
   3） NULL<>1 的返回结果是 NULL，而不是 true。

3. SQL影响操作安全或数据准确性方面的准则(红色为必须遵守，黑色为开发经验，必须掌握理)
1. 不要在开发代码中使用UPDATE、DELETE语句加LIMIT
说明：TRUNCATE TABLE 在功能上与不带WHERE子句的 DELETE 语句相同。
2. 程序连接不同的数据库使用不同的账号，禁止跨库查询
3. 去掉where 1=1 这样无意义或恒真的条件，如果遇到update/delete或遭到sql注入就恐怖了
4. SQL中不允许出现DDL语句。一般也不给予create/alter这类权限
5. 数据修正特别是删除、修改记录操作时,要先 select，避免出现误删除，确认无误才能执行更新语句。
6. TRUNCATE TABLE比DELETE速度快,且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发 trigger,有可能造成事故，
故不建议在开发代码中使用此语句。

7. 不使用反向查询，如 NOT IN ,NOT LIKE, 除非必要,否则能不用NOT IN就不用NOT IN ,坑太多了,会把空和NULL给查出来

4. SQL中字类型不一致，导致不走索引，影响性能(红色为必须遵守，黑色为开发经验，必须掌握理)
1).  WHERE条件中必须使用合适的类型，避免MySQL进行隐式类型转化，比如 SELECT id FROM TABLE WHERE id=1
2).  进行模糊查询时，禁止条件中字符串直接以“%”开头，如果有可以使用全文索引或者反向索引技术，提高效率
3).  WHERE条件中的非等值条件（！=，<>,IN、BETWEEN、<、<=、>、>=）会导致后面的条件使用不了索引。
4).  WHERE从句中禁止对索引列进行函数转换或表达式计算会导致无法使用索引
例: where date(createtime)='20160901'   改进:  where createtime >= '20160901' and createtime < '20160902'
例: WHERE data_format(tdate,'%Y-%m-%d %H:%i:%S')='2018-07-23 11:12:30' 
WHERE tdate= STR_TO_DATE('2018-07-23 11:12:30''%Y-%m-%d %H:%i:%S');
例: where amount*2=60   改进:  where amount = 60/2
例: where LOWER(email)='zhangsan@163.com'   改进: where email= UPPER('zhangsan@163.com');
返回小结果集不是很大的情况下，可以对返回列使用函数，简化程序开发,但是要明白用函数是不走索引的

隐式转换规则 （开发经验，必须掌握理）
字符与数字：   字符型向数字型转换
字符与日期：   字符弄向日期型转换
整型与日期：   整型向日期型转换
整型与浮点：   整型向浮点型转换
整型与定点：   整型向定点型转换
定点与浮点：   定点型向浮点型转换

有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp
有一个参数是 decimal 类型，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较

不做类型转换
两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 <=> 对两个 NULL 做比较时会返回 1，
这两种情况都不需要做类型转换

5. SQL 设计问题，影响性能(红色为必须遵守，黑色为开发经验，必须掌握理)
1). 事务要简单，单个事务的执行时间不宜太长，一个事务不要超过几分钟或几小时。
2). 禁止在数据库中跑大查询, sql语句尽可能简单，短事务、快速执行、无阻塞，大的sql想办法拆成小的sql语句, 
(充分利用QUERY CACHE和充分利用多核CPU) 。Mysql不支持SQL并行查询，一个SQL只能使用一个CPU进行计算
比如在一个事务里进行多个select，多个update，如果是高频事务，会严重影响MySQL并发能力，
因为事务持有的锁等资源只在事务rollback/commit时才能释放。但同时也要权衡数据写入的一致性。
3). 对数据的更新要打散后批量更新，不要一次更新太多数据






4). 不使用SELECT * 语句，查询哪几个字段就SELECT这几个字段, 
SELECT *返回结果中包含很多并不需要的字段，消耗更多的CPU和IO以及网络带宽资源
SELECT、INSERT语句必须显式的指明字段名称，
不合理：insert into inv_parameters  values(:field1,:field2,:field3);
改正:
合理insert into inv_parameters  (field1,field2,field3) Values (:field1,:field2,:field3)
5. 在不需要去重的情况下，用UNION ALL而不是UNION,UNION会把所有数据放到临时表中后再进行去重操作,
UNION ALL不会再对结果集进行去重操作
6. 避免使用大表的 JOIN ,JOIN消耗较多内存，每join一个表会多占用一部分内存 (join_buffer_size),会产生临时表操作，
影响查询效率, MySQL最多允许关联61个表, 减少关联表的数量，建议不超过4个,没有用的不要关联上
7. 禁止使用order by rand()，将数据从磁盘中读取，进行排序，会消耗大量的IO和CPU
8. 禁⽌单条SQL语句同时更新多个表
9. 不得使用数据库外键与级联，一切外键概念必须在应用层解决。 
说明：以学生和成绩的关系为例，学生表中的 student_id是主键，那么成绩表中的 student_id 则为外键。
如果更新学生表中的 student_id，
同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、
高并发集群；级联更新是强阻塞，
存在数据库更新风暴的风险；外键影响数据库的插入速度。
10. 禁止在多表关联的时候，在非索引字段上进行关联

11.  SQL中使用到OR的改写为用IN()  (很多情场情下OR的效率没有IN的效率高)
12.  某些场景，SQL中使用or 转化成 UNION ALL 效果更好
比如 OR 条件： f_phone=’10000’ or f_mobile=’10000’，两个字段各自有索引，但只能用到其中一个。
可以拆分成2个sql 用union all 连接起来
13.  SQL语句中IN包含的值不应过多，in 操作能避免则避免，若实在避免不了，里面数字的个数建议控制在 200以内
超过500个值使用分批的方式，否则一次执行会影响数据库的并发能力，因为单个SQL只能且一直占用单CPU，
而且可能导致主从复制延迟
14. 要学会使用EXIST代替IN，EXIST在一些场景查询会比IN快
  15. 在相同条件，查询和更新多个字段，建议放在一个查询中操作
        例如：使用SELECT column_name1, column_name2  FROM table  WHERE  [condition]
而不是SELECT column_name1 FROM table WHERE[condition] 和SELECT column_name2 FROM table WHERE [condition]
16. INSERT语句建议使用batch提交（INSERT INTO table VALUES(),(),()……），values的个数不应过多，
不然事务时间太长，影程程序并发能力，影响性能，影性主从同步
17. 不用/少用 FOR UPDATE、LOCK IN SHARE MODE，防止锁范围扩大化
18. 尽量避免使用子查询，子查询会产生临时表，临时表没有任何索引，数据量大时严重影响效率。建议把子查询转化成关联查询。
小于5.6版本时，子查询效率很低，不像Oracle那样先计算子查询后外层查询。5.6版本开始得到优化
例1  EXISTS , IN  查询 ：(注意检数据准确性，子表关联值具有唯一性，不然有可能考虑要去重
SELECT m.* FROM  m  WHERE EXISTS  ( SELECT 1 FROM n  WHERE m.code =n.code  AND n.type=1)
改进 SELECT m.* FROM  m  JOIN  n  ON m.code =n.code  WHERE  AND n.type=1

例2  NOT EXISTS ,NOT IN 
   SELECT m.* FROM  m WHERE m.code WHERE  NOT IN  ( SELECT n.code  FROM n  ) AND m.status=3
改进SELECT m.* FROM  m  LEFT JOIN  n  ON m.code =n.code  WHERE  AND  m.status=3 AND n.code IS NULL; 
19. 避免使用is null, is not null这样的比较
20. 能确定返回结果只有一条时，使用 limit 1 在保证数据不会有误的前提下，能确定结果集数量时，可以使用limit，
尽快的返回结果。
21. 使用join时，where条件尽量使用充分利用同一表上的索引
1)如select t1.a,t2, b * from t1,t2 and t1.a=t2.a and t1.b=123 and t2.c= 4 ，如果t1.c与t2.c字段相同，
那么t1上的索引(b,c)就只用到b了。
此时如果把where条件中的t2.c=4改成t1.c=4，那么可以用到完整的索引
2)这种情况可能会在字段冗余设计（反范式）时出现
22.  巧妙使用索引排序
例如：where  c1 < a order by c2
order by之前有个范围查询，由前面的内容可知，用不到类似(c1,c2)的索引
，但是可以利用(c2,c1)索引。另外还可以改写成join的方式实现。









23. 分页优化
说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下,要么控制返回的总页数，要么对超过特定阈值的页数进行 
.在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句


假如有类似下面分页语句:
SELECT … FROM table1 ORDER BY id LIMIT 10000,10;
推荐分页方式：
1.	传入上一次分页的界值 select … from table1  where id>10000  ORDER BY id limit 10 (id值要唯一才可取)
2.	通过索引来优化
SELECT … FROM table1 as t1 inner JOIN (SELECT id FROM table1 ORDER BY id LIMIT 10000，10) as t2 ON t1.id=t2.id
3.	只显示前几页的数据，比如前5页可显示页号，5页后面显示more,用户还要显示后面的数据，一次性全部展示,以减少重复性的I/O

24. count计数
1)首先count(*)、count(1)、count(col1)是有区别的，
count(*)表示整个结果集有多少条记录，
count(1)表示结果集里以primary key统计数量，绝大多数情况下count(*)与count(1)效果一样的，
count(col1)表示的是结果集里 col1 列 不为 NULL 的记录数。优先采用count(*)
2)大数据量count是消耗资源的操作，甚至会拖慢整个库，查询性能问题无法解决的，应从产品设计上进行重构。
例如当频繁需要count的查询，考虑使用汇总表
3)遇到distinct的情况，group by方式可能效率更高。

25. 使用合理的SQL语句减少与数据库的交互次数,尽量采用批量SQL语句，数据库更适合处理批量操作
INSERT ... ON DUPLICATE KEY UPDATE ...，插入行后如果会导致在一个UNIQUE索引或PRIMARY KEY中出现重复值，则执行UPDATE，
如果不重复则直接插入，影响1行。
REPLACE INTO类似，但它是冲突时删除旧行。再重新插入
INSERT IGNORE相反，保留旧行，丢弃要插入的新行。
INSERT INTO VALUES(),(),()，合并批量插入,一个事务中提交
26. 在程序中，建议使用预编译语句进行数据库操作。预编译只编译一次，多次使用，比SQL效率高







六. 注释规范(红色为必须遵守，黑色为开发经验，必须掌握理)
1. 所有表，字段，存储过程，函数，解发器都需要加注释，一般情况下，源程序有效注释量须在20%以上。
2. 注释的原则是有助于对程序阅读理解，在该加的地方都加，注释不宜太多也不能太少
3. 注释语言须准确、易懂、简洁. 注释内容要清晰、明了、含义准确，防止注释二义性.
4. 禁止在注释中使用缩写，特别是非常用的缩写。说明：在使用缩写时或之前，应进行必要的说明
5. 对存储过程的任何修改，都需要在注释最后添加修改人、修改日期及修改原因等信息。
6. 避免在一行代码或表达式的中间插入注释。
7. 保证注释的有效性，三种表示方法
1）从'#'字符开始到行尾。
2）从'--'序列到行尾。请注意‘--’(双破折号)注释风格要求第2个破折号后面至少跟一个空格符(例如空格、tab、换行符等等)，
由于这种注释方法经常导致出错，建议统一使用'#'进行注释
3）从/*序列到后面的*/序列。结束序列不一定在同一行中，因此该语法允许注释跨越多行


七．行为规范, 流程规范(红色为必须遵守，黑色为参考标准)
 (以下规范会涉及到相关只读库和分析库查询统计及数据导出)
1. 批量导入、导出大量数据必须提前通知DBA协助观察
2. 超过100万行的批量写操作，要分批多次进行操作
3. 对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境是不能忍受的.避免在对表字段进行修改时进行锁表
4. 推广活动或上线大规模的新功能须提前通知DBA,请求压力评估
5. 对于程序连接数据库账号，遵循权限最小原则
6. 程序使用的账号原则上不准有drop权限
7. 禁止有超级权限的应用程序账号存在，super权限只能留给DBA处理问题的账号使用
8. 对单表的多次alter操作必须合并为一次操作
9. 不允许在DBA不知情的情况下导现网数据
10. 产品出现非数据库导致的故障时及时通知DBA协助排查
11. 数据库数据丢失，及时联系DBA进行恢复
12. 对特别重要的库表，提前与DBA沟通确定维护和备份优先级
12. 不在业务高峰期批量更新、查询数据库
13. 数据库DDL及重要SQL及早提及DBA评审
14. 大批量更新，如修复数据，避开高峰期，并通知DBA。直接执行sql的由运维或DBA同事操作
